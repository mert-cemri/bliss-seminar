<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="generator" content="jemdoc, see http://jemdoc.jaboc.net/" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="jemdoc.css" type="text/css" />
<title>Jerry Li (Microsoft Research)</title>
<!-- MathJax -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
	  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<!-- End MathJax -->
</head>
<body>
<table summary="Table for page layout." id="tlayout">
<tr valign="top">
<td id="layout-menu">
<div class="menu-item"><a href="index.html">Seminar&nbsp;home</a></div>
<div class="menu-item"><a href="past.html">Past&nbsp;Talks</a></div>
</td>
<td id="layout-content">
<div id="toptitle">
<h1>Jerry Li (Microsoft Research)</h1>
</div>
<p>Oct 19, 2020</p>
<h2>Title and Abstract</h2>
<p><b>Faster and Simpler Algorithms for List Learning</b><br />
<br />
The goal of list learning is to understand how to learn basic statistics of a dataset when it has been corrupted by an overwhelming fraction of outliers. More formally, one is given a set of points \(S\), of which an \(\alpha\)-fraction \(T\) are promised to be well-behaved. The goal is then to output an \(O(1 / \alpha)\) sized list of candidate means, so that one of these candidates is close to the true mean of the points in \(T\). This formulation of the problem was first proposed in Charikar-Steinhardt-Valiant STOC&rsquo;17, which gave the first polynomial-time algorithm which achieved nearly-optimal error guarantees. More recently, exciting work of Cherapanamjeri-Mohanty-Yau FOCS&rsquo;20 gave an algorithm which ran in time \(\widetilde{O} (n d \mathrm{poly} (1 / \alpha))\). In particular, this runtime is nearly linear in the input size for \(1/\alpha = O(1)\), however, the runtime quickly becomes impractical for reasonably small \(1/\alpha\). Moreover, both of these algorithms are quite complicated.</p>
<p>In our work, we have two main contributions. First, we give a very simple polynomial time algorithm for this problem which achieves optimal error. Second, we then build off of these insights to develop a somewhat more sophisticated algorithm based on lazy mirror descent which runs in time \(\widetilde{O}(n d / \alpha + 1/\alpha^6)\), and which also achieves optimal error. Our algorithm improves upon the runtime of previous work for all \(1/\alpha = O(\sqrt{d}\). The goal of this talk is to give a more or less self-contained proof of the first, and then explain at a high level how to use these ideas to develop our faster algorithm.</p>
<p>Joint work with Ilias Diakonikolas, Daniel Kane, Daniel Kongsgaard, and Kevin Tian</p>
<h2>Bio</h2>
<p>Jerry Li is a Senior Researcher at Microsoft Research. He completed his PhD at MIT under the supervision of Ankur Moitra, after completing his Masters at MIT and his undergraduate at UW. Subsequently, he did a postdoc at the Simons Institute at UC Berkeley. His work focuses largely on high dimensional statistical learning theory and machine learning, with a particular focus towards understanding how and why learned models are robust. For his work, he has been awarded the George Sprowls award for Outstanding Thesis in EECS at MIT, various special issue invitations, and an invitation to appear in the Communications of the ACM. Outside of work, he enjoys being killed first in Among Us, and being really bad at playing the imposter</p>
<div id="footer">
<div id="footer-text">
Page generated 2020-11-13 18:20:04 PST, by <a href="https://github.com/wsshin/jemdoc_mathjax" target="blank">jemdoc+MathJax</a>.
</div>
</div>
</td>
</tr>
</table>
</body>
</html>
